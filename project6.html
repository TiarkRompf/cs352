<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>CS352 by TiarkRompf</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <style>
    .ttt {font-family: monospace; font-size: 12px; font-style: normal;}
    </style>
  </head>
  <body>
    <div class="wrapper">
      <header class="without-description">
        <h1>CS352</h1>
        <p></p>
        <p class="view"><a href="https://github.com/TiarkRompf/cs352">View the Project on GitHub <small>TiarkRompf/cs352</small></a></p>
        <ul>
          <li><a href="index.html"><strong>Home</strong></a></li>
        </ul>
      </header>
      <section>
<!--content-->

      <div class="title">
        <h1>Project 6: Optimization</h1>
      </div>

      <blockquote>
        <p>Due 11:59PM Thursday Nov 9</p>
      </blockquote>

<p>Download the skeleton code for the project <a href="https://www.cs.purdue.edu/homes/gesserte/cs352/project/proj6.tar.gz">here.</a>

<p>Your task in this assignment is to implement a series of optimizations for the CPS compiler. In the skeleton code you will find <span class="ttt">src/miniscala/CPSOptimizer.scala</span>. This file contains the optimizer mechanism, followed by two specific instantiations: <span class="ttt">CPSOptimizerHigh</span> and <span class="ttt">CPSOptimizerLow</span>. Your task is to fill in the optimizer mechanism, which consists of shrinking and non-shrinking optimizations (as described in the lectures) and the specific implementation of <span class="ttt">CPSOptimizerHigh</span>. The specific implementation of <span class="ttt">CPSOptimizerLow</span> is given.</p>
<p>More specifically, you are expected to implement:</p>
<ul>
<li>Dead code elimination
<li>Common-subexpression elimination
<li>Constant folding
<li>Neutral/absorbing elements optimization
<li>Shrinking inlining
<li>General inlining, according to a predetermined heuristics (see below)
</ul>
<p>For bonus grade, you may implement:</p>
<ul><li>Block primitive optimizations</li></ul>

<p>For fun and fame (see optimization challenge), you may implement:</p>
<ul><li>Any optimizations you can think about</li></ul>

<p>Do not implement:</p>
<ul>
<li>Î·-reduction
<li>Contification
</ul>
<p>Once the optimizer is fully functional, it should optimize the following example correctly:</p>
<p><b>Input:</b></p>
<pre>
  def printChar(c: Int) = putchar(c);
  def functionCompose(f: Int => Int, g: Int => Int) = (x: Int) => f(g(x));
  def plus(x: Int, y: Int) = x + y;
  def succ(x: Int) = x + 1;
  def twice(x: Int) = x + x;
  printChar(functionCompose(succ,twice)(39));
  printChar(functionCompose(succ,succ)(73));
  printChar(functionCompose(twice,succ)(4))
</pre>
<p><b>Output:</b></p>
<pre>
  (let* ((v$1 79)
         (v$2 (char-print v$1))
         (v$3 75)
         (v$4 (char-print v$3))
         (v$5 10)
         (v$6 (char-print v$5)))
    (halt))
</pre>
<p>Closures? Blocks? The optimizer eliminated all abstractions and gave us the simplest inline code possible. :D
<br>
Now, to start hacking on the optimizer:</p>
<pre>
cd proj6/compiler
sbt
> run ../library/miniscala.lib ../examples/pascal.scala
...
[info] Running miniscala.Main ../library/miniscala.lib ../examples/pascal.scala
enter size (0 to exit)> 12
(1 11 55 165 330 462 462 330 165 55 11 1 )
(1 10 45 120 210 252 210 120 45 10 1 )
(1 9 36 84 126 126 84 36 9 1 )
(1 8 28 56 70 56 28 8 1 )
(1 7 21 35 35 21 7 1 )
(1 6 15 20 15 6 1 )
(1 5 10 10 5 1 )
(1 4 6 4 1 )
(1 3 3 1 )
(1 2 1 )
(1 1 )
(1 )
enter size (0 to exit)> 0
Instruction Stats
=================
    6205  LetP
    2998  LetL
    ...
</pre>
<p>The "Instruction stats" indicate <b>how many instructions were executed</b> while computing the pascal triangle. This is in contrast to the total instructions in the output program, which is constant regardless of the input.</p>

<h2>Notes on Implementation</h2>

<p>The implementation sketch that is given to you is not a trivial mapping of the theory into code, so here are some notes to guide you through it.</p>

<p>The optimizations are split in shrinking (in method <span class="ttt">shrink</span>) and non-shrinking (or general inlining, in method <span class="ttt">inline</span>) optimizations. Remember that shrinking optimizations are safe to apply as often as desired, while inlining may lead to arbitrarily large code, or even diverge the optimizer.</p>

<p>The general idea of the optimizer (see method <span class="ttt">apply</span>) is the following: After an initial step of iteratively applying <span class="ttt">shrink</span> until a fixed point, we iteratively apply a step of <span class="ttt">inline</span> and a step of <span class="ttt">shrink</span> until one of the following happens:</p>
<ul>
<li>The tree does not change
<li>We reach a specified number of iterations, or
<li>The resulting tree's size exceeds <span class="ttt">maxSize</span>, given as a function of the initial size.
<li>The two first conditions are checked by the <span class="ttt">fixedPoint</span> function itself, while the third is checked within <span class="ttt">inline</span>.
</ul>
<p>The <span class="ttt">inline</span> function is actually a small series of inlining steps. During each inlining step, we choose to inline functions/continuations of increasing size. For continuations, this size is linear to the number of steps, but for functions it is exponential (according to the Fibonacci sequence). We stop inlining after a specified number of steps, or if the tree grows to more than <span class="ttt">maxSize.</span></p>

<p>The internal traversals of both the <span class="ttt">shrink</span> and <span class="ttt">inline</span> functions accept an implicit argument of the <span class="ttt">State</span> type, which, as you may have guessed, tracks the local state of the optimization. You are supposed to update it as you traverse the subtrees using the designated methods. The descriptions in the source file will hopefully make each field's role to the optimization clear.</p>

<h2>Testing</h2>

<p>Testing will be slightly different this time. We have 3 sets of tests:</p>
<ul>
<li><b>Blackbox</b> tests check the program you output runs correctly, therefore the optimizations keep the semantics of the language (see <span class="ttt">test/miniscala/test/CPSOptimizer_Blackbox.scala</span>)</li>
<li><b>Greybox</b> tests execute the program while recording the execution trace and then require certain properties of the trace, such as, for example that at most 2 functions were defined (see <span class="ttt">test/miniscala/test/CPSOptimizer_Greybox.scala</span> and the additions to <span class="ttt">src/miniscala/CPSInterpreter.scala</span> for more details)
<li><b>Optimization challenge</b> allows showing off how good your optimizer is on larger applications: we will run an example application and output the execution statistics (see <span class="ttt">src/miniscala/CPSInterpreter.scala</span>) -- you can compete with your colleagues and with our reference implementation to get the best results possible. And yes, you should brag about your results on Piazza!</li>
</ul>
<p>This assignment gives you a lot of liberty into how and what you optimize, so go ahead and write the best optimizer in the entire class!</p>

<h2>Turning In</h2>

<p>The project is due by November 20, 11:59PM. To turn in your project, go to the same directory that your <i>proj6</i> directory lives in (you do not have to name it proj6, but it must contain all of the project files) and type:<br>
<pre>
turnin -c cs352 -p proj6 proj6
</pre>
<p>You can verify the status of your turned in project by running:</p>
<pre>
turnin -c cs352 -p proj6 -v
</pre>
</p>

<h2>Challenge Results</h2>

<p>For the reference compiler we have developed, the challenge results are given below. Different results form these statistics are encouraged, especially if they reduce the numbers in one category or the other.</p>

<pre>
Challenge: maze.scala with 12 for both inputs.
Instruction Stats
=================
 1320209  LetP
 1076643  LetL
 1003773  LetC
  446036  If
  293889  AppF
  113226  AppC
       1  LetF
       1  Halt

Value Primitives Stats
======================
  510160  CPSBlockGet$
  247412  CPSOr$
  241868  CPSArithShiftL$
  239466  CPSBlockTag$
   30504  CPSBlockSet$
   14660  CPSBlockAlloc
   10367  CPSSub$
   10105  CPSAdd$
    8621  CPSArithShiftR$
    3433  CPSAnd$
    1611  CPSMul$
    1056  CPSXOr$
     662  CPSByteWrite$
     264  CPSMod$
      14  CPSBlockLength$
       6  CPSByteRead$

Logic Primitives Stats
======================
  380718  CPSEq$
   63198  CPSNe$
    2058  CPSLt$
      52  CPSGt$
      10  CPSLe$

Functions defined: 27
Continuations defined: 1003773
</pre>

<!--/content-->

      </section>
    </div>
    <footer>
      <p>Project maintained by <a href="https://github.com/TiarkRompf">TiarkRompf</a></p>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

  </body>
</html>
