<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>CS352 by TiarkRompf</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header class="without-description">
        <h1>CS352</h1>
        <p></p>
        <p class="view"><a href="https://github.com/TiarkRompf/cs352">View the Project on GitHub <small>TiarkRompf/cs352</small></a></p>
        <ul>
          <li><a href="index.html"><strong>Home</strong></a></li>
        </ul>
      </header>
      <section>


      <div class="title">
        <h1>Project 1: Mathematics expression parser</h1>
      </div>

      <blockquote>
        <p>Due 11:59pm Sunday Aug 27</p>
      </blockquote>

<h2>Useful Links</h2>
<ul>
  <li><a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf">x86_64 cheat sheet (up to page 3 for this project)</a></li>
</ul>
<h2>Introduction</h2>
<p>
The goal of this project is to setup the environment and to learn how to parse and translate mathematical expressions into x86_64 assembly code. Our approach will be simple and the objective is to highlight some of the key aspects and ideas behind a compiler.</p>

<p>For this first project we are going to keep thing very simple and take very small steps. Make sure that you understand correctly before going to the next step.</p>

<p>At the end of the project we will be able to parse mathematical expressions with single digit numbers, additions, substractions, multiplications, divisions, and parenthesis. Our parser will generate an intermediate representation in the form of an Abstract Syntax Tree (AST). The definition of the AST is the one used during the lecture.</p>

<p>In parallel, we will implement a generator that convert the AST into x86_64 code.</p>

<p>Here a small example of what we will be able to generate by the end of the project:</p>
<pre>
[info] Running project1.Runner 2+3
============= AST ================
	Plus(Lit(2),Lit(3))
==================================

============ OUTPUT ==============
.text
	.global entry_point

entry_point:
	push %rbp	# save stack frame for C convention
	mov %rsp, %rbp

	# beginning generated code
	movq $2, %rbx
	movq $3, %rcx
	addq %rcx, %rbx
	movq %rbx, %rax
	# end generated code
	# %rax contains the result

	mov %rbp, %rsp	# reset frame
	pop %rbp
	ret



==================================
Result: 5
</pre>

<h2>Step 1: Getting started</h2>

<p>The first step of this assignment is to set up your environment, as described in the <a href="getting_started.html">Getting Started - Tools page</a>. If you have any trouble installing the tools for the course ask the TAs for help.</p>

<p>Note that all of the prerequisites, even Eclipse, are installed on the CS department linux machines, and you are free to use an X server such as <a href="https://sourceforge.net/projects/xming/">xming</a> to do the project remotely or follow these <a href="https://www.cs.purdue.edu/resources/facilities/remote-access.html#RShell">instructions</a> to access the lab machines remotely. Alternatively you may do the project on your own machine and then upload your results to your home directory on data.cs.purdue.edu and turn in your results using turnin.</p>


<p>The project has been designed and tested for Linux/Mac OS. If you do not own a personal laptop with these OS and do not know how to use the tools requires on Windows, you should use the lab machines for the project.</p>

<p>If you use remote access to work on your project. Please use one of the lab machine pod1-1 to pod1-20 with the suffix cs.purdue.edu (e.g. pod1-1.cs.purdue.edu)</p>

<p>Download the skeleton file <a href="https://www.cs.purdue.edu/homes/gesserte/cs352/project/proj1.tar.gz">here</a> .</p>

<pre>
tar xzvf proj1.tar.gz
cd proj1
</pre>


<h2>Step 2: Project structure</h2>

<h3>Open project with Eclipse</h3>
<p>In order to open the project with Eclipse, you first need to generate an Eclipse project:
<pre>
sbt eclipse
</pre>

and then import the Project into Eclipse: <b>File > Import > Existing project into Workspace</b>. Select the root folder proj1 and hit <b>Finish</b>.</p>

<h3>Take a look at the files</h3>

<p>A description of the different files is provided below. The two files you need to complete are <b>Parser.scala</b> and <b>Generator.scala</b>. Each parser that we are going to implement are building on top of each other so you need to implements them in order by following the comments in the code. We will implements two different generators using two different strategies. It is recommended to implement the <b>StackASMGenerator</b> class when it is suggested in the <b>Parser.scala</b> file and at the end implement the <b>RegASMGenerator</b>.</p>

<h3>build.sbt and project/plugin.sbt</h3>
<p>Scala Build Tool (sbt) is an open source build tool for Scala and Java project. These files contain the information necessary to compile this project. You should not have to modify them.

<p>To use sbt, launch a terminal and go to the project directory (proj1) and type 'sbt'. It will lauch an sbt console. You can run the program from there:
<pre>
    run "arg1" "arg2" // run main program with arguments arg1 and arg2
    run "1+3*(5-8)"
    test              // run all the tests application (in src/test)
</pre>


<h3>src/main/scala/project1/Util.scala</h3>

<p>This file defined multiple classes that are used to generate the code and run it on your machine. Nothing needs to be modified, but it is recommanded to read it and have an idea of what is happening behind the scene.</p>

<h3>gen/bootstrap.c</h3>

<p>Like we are generating assembly code which is OS dependent, we are using GCC to do the heavy lifting for us. The boostrap file is a generic C file that is calling a function <b>entry_point</b> and is printing the result in <b>stdout</b>. Our compiler will generate the file <b>gen/gen.s</b> and will be assemble and bootstraped by gcc:</p>

<pre>gcc bootstrap.c gen.s -o out</pre>

<p><b>out</b> will then print the result of our compiled expression.</p>

<p>NOTE: the assembly/compilation and running steps are executed through the code. (see Util.scala#L77 and Main.scala#L35)</p>

<h3>src/main/scala/project1/Main.scala</h3>

<p>The main function is defined in this file. During this project you will be implementing many different parsers, in order to test them through the main function you will need to modify the parser or generator you want to use.</p>

<h3>src/main/scala/project1/Parser.scala</h3>

<p>This class contains the definition of our intermediate language. This is the language we are using in class, please refere to the lecture for more information.</p>

<p>The class <b>SimpleParser</b> defined in this file is the basic parser that we are going to use for this project. It is reading a stream of characters one at a time and can extract a single digit number <b>getNum</b> or a single letter name <b>getName</b>. It does not handling white spaces.</p>

<p>We are keeping the parser very simple at the beginning to focus on the important concept. Later on we will improve it to handle multiple digits numbers and more expressions. We will also support white spaces.</p>

<p>The rest of the file is the definition of each parser we are building. Starting from single number expression to the full language we want to target. What you have to do for this project is highlighted with TODOs in the code. We encourage you to read the comments and code carefully before preceeding.</p>

<h3>src/main/scala/project1/Generator.scala</h3>

<p>In this file, we are defining some generators that can convert our AST into x86_64 code.</p>

<p>We are considering two different ways of generating the assmbly code. Each of them having their own pros and cons. <b>Stack-based</b> code, which is not very efficient but can handle arbitrary complexe expressions. <b>Register-based</b> code, which is efficient but can not handle arbitrary complexe expressions. We will see later than compilers use a hybrid approach.</p>

<h3>src/test/scala/*Test.scala</h3>

<p>These files contain some unit tests for the first parsers. You will have to write your own tests for the others. There are some function given to you in order to make the implementation easier.</p>

<h2>Turnin</h2>
<p>You should turn in <b>proj1</b> directory. Please run a 'sbt clean' before submitting.</p>

<p>
To turn in your project, make sure that you are in the directory that contains <b>proj1</b> directory. Then type the following:
</p>
<pre>
turnin -c cs352 -p project1 proj1
</pre>
<p>To verify your turned-in work, do:</p>
<pre>
turnin -c cs352 -p project1 -v
</pre>
<h2>Grading</h2>
<p>TBD



      </section>
    </div>
    <footer>
      <p>Project maintained by <a href="https://github.com/TiarkRompf">TiarkRompf</a></p>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->

  </body>
</html>
